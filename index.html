<!DOCTYPE html>
<html>

<head>
      <!-- Required meta tags -->
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- leaflet for map in browser -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet-src.js" integrity="sha512-IkGU/uDhB9u9F8k+2OsA6XXoowIhOuQL1NTgNZHY1nkURnqEGlDZq3GsfmdJdKFe1k1zOc6YU2K7qY+hF9AodA==" crossorigin=""></script>

    <!-- turf for spatial calculations -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>

    <script src="https://momentjs.com/downloads/moment.js"></script>

    <!--proj4 for projection and transformation -->
    <script src="https://unpkg.com/proj4@2.4.4/dist/proj4-src.js"></script>
    <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>

    <!-- omnivore and csv2geoJson for conversion of csv (and such) to GeoJson and leaflet compliant structures -->
    <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.js"></script>
    <script src="https://npmcdn.com/csv2geojson@latest/csv2geojson.js"></script>
    <!-- for csv parsing  -->
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>

    <!-- Jquery for js/ file manip... prev used 2.1.3-->
    <script
			  src="https://code.jquery.com/jquery-3.4.1.min.js"
			  integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
			  crossorigin="anonymous"></script>

      <!-- bootstrap so we can do simple page styling -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  

    <!-- visualize it -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.datatables.net/1.10.20/js/jquery.dataTables.min.js"></script>
    <link rel="stylesheet" href="https://cdn.datatables.net/1.10.20/css/jquery.dataTables.min.css" />

    <!-- Slider (Jquery UI) -->
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="https://jqueryui.com/resources/demos/style.css">
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

    <!--Alertify make prompts easy-->
    
<!-- JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/alertifyjs@1.12.0/build/alertify.min.js"></script>

<!-- CSS -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/alertifyjs@1.12.0/build/css/alertify.min.css"/>
<!-- Bootstrap theme -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/alertifyjs@1.12.0/build/css/themes/bootstrap.min.css"/>
<!-- Bootstrap theme -->
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/alertifyjs@1.12.0/build/css/themes/bootstrap.rtl.min.css"/>

  </head>

<body>
  <div class="container">
    <div class="row">
      <form class="form-inline">
        <div class="form-group">
          <label for="files">Upload a CSV formatted file:</label>
          <input type="file" id="files"  class="form-control" accept=".csv" required />
        </div>
        <div class="form-group">
        <button type="submit" id="submit-file" class="btn btn-primary">Upload File</button>
        </div>
      </form>
    </div><!-- end input DIV -->

    currently expects CSV with columns user, lat, lon, time 
    <br> user is a delimiter identifier to differentiate between different tracks
    <br>Lat and lon are expected in WGS84 decimal degrees
    <br>(time can be in any date/time format)

    <!--map and filters float: left; margin-left: 45%;   -->
    <div class="row">
        <div class="col-sm">
          <div id="map" style="height: 300px;"></div>
        </div>
        <div class="col-sm">
          <div id="sliders" style="height: 300px;">
            <p>
                <label for="dist-amount">Distance between points (km):</label>
                <input type="text" id="dist-amount" style="border:0; color:#f6931f; font-weight:bold;">
            </p>
              <div id="dist-range"></div>
            <p>
                <label for="speed-amount">Speeds between points (kmh):</label>
                <input type="text" id="speed-amount" style="border:0; color:#f6931f; font-weight:bold;">
            </p>
              <div id="speed-range"></div>
              <button onclick="filterTrack()">redraw tracks using selected filters</button> 
          </div>
        </div>
    </div>

    <div class="row">


        <!-- Nav tabs -->
        <div class="card text-center">
            <div class="card-header">
              <ul class="nav nav-tabs">
                <li class="nav-item">
                  <a class="nav-link active" data-toggle="tab" href="#speed_distribution_violins">Speed Distributions</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" data-toggle="tab" href="#dist_distribution_violins">Distance Distributions</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" data-toggle="tab" href="#speed_over_time">Speeds over time</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" data-toggle="tab" href="#computed_table">Computed data table</a>
                  </li>

                <li class="nav-item">
                  <a class="nav-link" data-toggle="tab" href="#data_table">Raw data table</a>
                </li>
              </ul>
            </div>

        <!-- Tab panes -->
        <div class="card-body"></div>
            <div class="tab-content">

              <div class="tab-pane container active" id="speed_distribution_violins">
                  <div class="col-sm" >
                      <div id="d3_speeds" ></div>  <!--width:49%;float: left;-->
                  </div>
              </div>
              <div class="tab-pane container fade" id="dist_distribution_violins">
                  <div class="col-sm" >
                      <div id="d3_distances" ></div> <!--margin-left: 50%; height: 600px; width:49%-->
                  </div>
              </div>
              
              <div class="tab-pane container fade" id="speed_over_time">
                ...
                  <div class="col-sm" >
                      <div id="d3_speed_v_time" ></div> <!--margin-left: 50%; height: 600px; width:49%-->
                  </div>
              </div>
              <div class="tab-pane container fade" id="computed_table">
                  <table id="computed_table_in" class="display"></table>
              </div>
              <div class="tab-pane container fade" id="data_table">
                  <table id="dataTable_in" class="display" style="width:30%"></table>
              </div>
              
            </div>
      </div>
    </div>
  </div>

<!-- 
  the form to be viewed as dialog  
https://stackoverflow.com/questions/31780423/alertify-prompt-allow-user-to-input-values-and-submit-form
-->
<form id="defineColumnsForm" style="display:none;">
    <fieldset>
        <label> 'user' column is a delimiter identifier to differentiate between different tracks </label>
        <input type="text" value="user" id="user_column"/> 

        <label> 'time' column when user was at each point </label>
        <input type="text" value="time" id="time_column"/> 

        <label> Latitude column  (WGS84 in decimal degrees) </label>
        <input type="text" value="lat" id="lat_column"/> 

        <label> Longitude column  (WGS84 in decimal degrees) </label>
        <input type="text" value="lon" id="lon_column /> 

        <input type="submit" value="load data"/>
    </fieldset>
</form>


  <script>
    
    var raw_tracks = L.geoJSON(); //L.layerGroup();
    var filtered_tracks = L.geoJSON();

// L.marker([39.61, -105.02]).bindPopup('This is Littleton, CO.').addTo(cities),
// L.marker([39.74, -104.99]).bindPopup('This is Denver, CO.').addTo(cities),
// L.marker([39.73, -104.8]).bindPopup('This is Aurora, CO.').addTo(cities),
// L.marker([39.77, -105.23]).bindPopup('This is Golden, CO.').addTo(cities);


var mbAttr = 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
    '<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
    'Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
  mbUrl = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';

var grayscale   = L.tileLayer(mbUrl, {id: 'mapbox.light', attribution: mbAttr}),
  streets  = L.tileLayer(mbUrl, {id: 'mapbox.streets',   attribution: mbAttr});

var map = L.map('map', {
  center: [9.73, -1.99],
  zoom: 5,
  layers: [grayscale, raw_tracks,filtered_tracks]
});

var baseLayers = {
  "Grayscale": grayscale,
  "Streets": streets
};

var overlays = {
  "raw_tracks": raw_tracks,
  "filtered_tracks":filtered_tracks
};
L.control.layers(baseLayers, overlays).addTo(map);
///// end map setup ///

var lat_column = "lat";
var lon_column = "lon";
var time_column = "time";
var user_column = "user";

$('#submit-file').on("click",function(e){
  e.preventDefault();
  
  Papa.parse($('input[type=file]')[0].files[0], {
    header:true,
    config: {
        delimiter: "auto",
      },
      before: function(file, inputElem) {
        console.log("Parsing file...", file);
      },
      error: function(err, file){
        //console.log("ERROR:", err, file);
      },
      complete: function(data){
        //displayHTMLTable(data);
        
        json_2_dataTable(data, 'dataTable_in');
        console.log("Done with all files");
        csv_to_lineStrings(data, "user", "time", 
              "lat",  "lon");
        //add_data_to_map(Papa.unparse(data) );
      }
    });
  
});

function json_2_dataTable(result, div_id){
  var t_columns = Object.keys(result.data[0]).map(function(x){ return { title: x}; })
  var rows = result.data.map(function(row){ 
            return t_columns.map(function(col){
                if(row.hasOwnProperty(col.title) &&
                  row[col.title] != undefined){
                      return row[col.title];
                  }else{
                    return "";
                  }
              }); 
          });
  $('#'+div_id).DataTable( {
        data: rows,
        columns: t_columns
    } );
}

/// parse CSV and show
function displayHTMLTable(results){
	var table = "<table class='table'>";
	var data = results.data;
   console.log(results);
   
	for(i=0;i<data.length;i++){
		table+= "<tr>";
		var row = data[i];
		var cells = row.join(",").split(",");
		 
		for(j=0;j<cells.length;j++){
			table+= "<td>";
			table+= cells[j];
			table+= "</th>";
		}
		table+= "</tr>";
	}
	table+= "</table>";
	$("#parsed_csv_list").html(table);
  add_data_to_map(results);
}

var organized_data = {};
function csv_to_lineStrings(data_in, userColumn, timeColumn, 
              latColumn,  lonColumn){
  console.log(data_in);
  var data = data_in.data;
  //var computed_rows = {data: ['start_point', 'end_point','dist(meters)','time_delta(hours)','meter_per_hour','bearing']};
  var computed_rows = {data: []};
  // create lists for each user
  for(var i=0; i<data.length; i+=1) {
    var uuid = data[i][userColumn];
    var lat = parseFloat(data[i][latColumn]);
    var lon = parseFloat(data[i][lonColumn]);
    var timestamp = moment(data[i][timeColumn]);
    if(!organized_data.hasOwnProperty(uuid)){
      organized_data[uuid] = [];
    }
    if(lon==NaN | lat==NaN){
      console.log(uuid,lat,lon,timestamp);
    }
    if(lon!=NaN && lat!=NaN){
      try {
      organized_data[uuid].push( {'timestamp':timestamp,
                        'coord': turf.point([lon, lat])});
      } catch(err){
        console.log("failed on row ", data[i]);
      }
    }
  };
  // now do something with our sorted data
  var unique_uid = Object.keys(organized_data);
  var user_2_speeds = {};
  var user_2_dist = {};
  var user_2_timeSeries = {};

  // sort data by time
  for(var i=0; i<unique_uid.length; i+=1) {
    organized_data[unique_uid[i]].sort( compareTimeStamp );
    user_2_speeds[unique_uid[i]] = [];
    user_2_dist[unique_uid[i]] = [];
    user_2_timeSeries[unique_uid[i]] = [];
    //
    for(var j=1; j<organized_data[unique_uid[i]].length; j+=1){
      var row0 = organized_data[unique_uid[i]][j-1];
      var row1 = organized_data[unique_uid[i]][j];
      var dist = turf.distance(row0.coord, row1.coord);
      var bearing = turf.bearing(row0.coord, row1.coord);
      var time_delta=(row1.timestamp - row0.timestamp)/3600000;
      var meter_per_hour = dist/time_delta 
      user_2_speeds[unique_uid[i]].push( meter_per_hour );
      user_2_dist[unique_uid[i]].push( dist );
      var t_row = {"user":unique_uid[i], "start_point":row0.coord, "end_point":row1.coord, "dist_meter":dist,
               "start_time":row0.timestamp,"time_Delta(hour)":time_delta,
               "meter_per_hour":meter_per_hour, "bearing":bearing};
      //var t_row = [row0.coord, row1.coord,dist,time_delta,meter_per_hour,bearing];
      computed_rows['data'].push(t_row);
      user_2_timeSeries[unique_uid[i]].push(t_row);
    }

    var coords = organized_data[unique_uid[i]].map(function(row){ return row.coord;});
    // add each line to map
    if (coords.length>1){
      var geoJson_csv = turf.lineString(coords.map(function(gJson){
        return gJson.geometry.coordinates;
      }));
      //var customLayer = L.geoJSON( geoJson_csv );
      //  customLayer.addTo(map);
        //add data to raw_tracks
        raw_tracks.addData(geoJson_csv);
     }
  }
  // create graphs
  console.log('user_2_speeds',user_2_speeds);
  create_speed_violin_plot(user_2_speeds);
  create_distance_violin_plot(user_2_dist);

  console.log('organized_data');
  console.log(organized_data);
  create_basic_track_filters(organized_data, true);

  // create computed data table
  json_2_dataTable(computed_rows, 'computed_table_in');
  // create basic temporal graph
  create_d3_speed_v_time(user_2_timeSeries, "start_time", "meter_per_hour");
};

function compareTimeStamp( a, b ) {
  // change time to wtvr field has timestamp
  if ( a.time < b.time ){
    return -1;
  }
  if ( a.time > b.time ){
    return 1;
  }
  return 0;
}


// calculate dist, speed, etc... for all point combinations
var user_coords_summary = {};

function create_distance_violin_plot(data_in) {
  var users = Object.keys(data_in);
  var data = [];
  for(var i=0; i<users.length; i+=1) {
      if(data_in[users[i]].length >0){
        var trace = {
            text: "sample length: 58",
            hoveron: "points+kde",
            meanline: { visible: true },
            legendgroup: "Yes",
            scalegroup: "Yes",
            points: "all",
            pointpos: -0.9,
            box: { visible: true },
            jitter: 0,
            scalemode: "count",
            marker: {
                line: {width: 2, color: "#8dd3c7"},
                symbol: "line-ns"
            },
            showlegend: false,
            //side: "negative",
            type: "violin",
            name: "M",
            span: [0],
            line: { color: "#8dd3c7" },
            y0: users[i],
            x: data_in[users[i]],
            orientation: "h"
      };
    data.push(trace);
      }
  }

  var layout = {
          hovermode: "closest",
          width: '48%',
          yaxis: {
              showgrid: true
          },
          title: "distance distribution",
          legend: {
              tracegroupgap: 0
          },
          violingap: 0,
          violingroupgap: 0,
          violinmode: "overlay",
          height: 700
      }

  Plotly.plot('d3_distances', data, layout);
}

function create_speed_violin_plot(data_in) {

  console.log(data_in);
  var users = Object.keys(data_in);
  var data = [];
  for(var i=0; i<users.length; i+=1) {
    var trace = {
            text: "sample length: 58",
            hoveron: "points+kde",
            meanline: { visible: true },
            legendgroup: "Yes",
            scalegroup: "Yes",
            points: "all",
            pointpos: -0.9,
            box: { visible: true },
            jitter: 0,
            scalemode: "count",
            marker: {
                line: {width: 2, color: "#8dd3c7"},
                symbol: "line-ns"
            },
            showlegend: false,
            //side: "negative",
            type: "violin",
            name: "M",
            span: [0],
            line: { color: "#8dd3c7" },
            y0:  users[i],
            x: data_in[users[i]],
            orientation: "h"
      };
      data.push(trace);
  }
  
  var layout = {
          hovermode: "closest",
          width: '48%',
          yaxis: {
              showgrid: true
          },
          title: "speed distribution",
          legend: {
              tracegroupgap: 0
          },
          violingap: 0,
          violingroupgap: 0,
          violinmode: "overlay",
          height: 700
      }

  Plotly.plot('d3_speeds', data, layout);
}

function create_d3_speed_v_time(data_in, date_column, values_column){
  var users = Object.keys(data_in);
  console.log("create_d3_speed_v_time",data_in)
  var data = [];
  for(var i=0; i<users.length; i+=1) {
    var user_id = users[i];
    // array of 
    var date_vector = []
    var values_vector = []
    var users_data = data_in[users[i]];
    for(var b=0; b<users_data.length; b+=1) {
      var date_string = users_data[b][date_column].toISOString();
      var val = users_data[b][values_column];
      date_vector.push( date_string );
      values_vector.push( val );
    }
    console.log(date_column,date_vector)
    var trace = { type: "scatter",
                mode: "lines",
                name: user_id,
                x: date_vector,
                y: values_vector,
                line: {color: '#7F7F7F'}
              }
      data.push(trace);
  }
  
  var layout = {
    title: 'Time Series',
  };

  Plotly.plot('d3_speed_v_time', data, layout);
}
function filterTrack(){
  filtered_tracks.clearLayers();
  var min_dist_filter = $( "#dist-range" ).slider( "values", 0 );
  var max_dist_filter = $( "#dist-range" ).slider( "values", 1 );
  var min_speed_filter = $( "#speed-range" ).slider( "values", 0 );
  var max_speed_filter = $( "#speed-range" ).slider( "values", 1 );
  // loop through our point-2-point metrics and only keep the onse passing these filters
  // now do something with our sorted data
  var filtered_data = {}
  var unique_uid = Object.keys(organized_data);
  var user_2_speeds = {};
  var user_2_dist = {};

  // sort data by time
  for(var i=0; i<unique_uid.length; i+=1) {
    console.log('filtering points for user: '+unique_uid[i]);
    if(unique_uid[i]==undefined){
      continue;
    }
    organized_data[unique_uid[i]].sort( compareTimeStamp );
    user_2_speeds[unique_uid[i]] = [];
    user_2_dist[unique_uid[i]] = [];
    // create new filtered entry for user
    filtered_data[unique_uid[i]] = [];
    var num_user_points = organized_data[unique_uid[i]].length;

    var points_used = [];
    // loop through points
    for(var j=0; j<organized_data[unique_uid[i]].length;){
      var row0 = organized_data[unique_uid[i]][j];

      // add first point of segment to our coord out
      if(points_used.indexOf(j)==-1){
        filtered_data[unique_uid[i]].push(organized_data[unique_uid[i]][j]);
        points_used.push(j);
      }

      // check if segment meets the user entered filter
      var keep_searching = true;
      var end_segment_index = j;
      while(keep_searching){
        end_segment_index+=1;
        if( end_segment_index>=organized_data[unique_uid[i]].length){
          keep_searching=false;
          continue;
        }
        // get next row (data is already sorted by time)
        var row1 = organized_data[unique_uid[i]][end_segment_index];
        var dist = turf.distance(row0.coord, row1.coord);
        var time_delta=(row1.timestamp - row0.timestamp)/3600000;
        var kmh = dist/time_delta;
        //console.log('comparing points ('+j+','+end_segment_index+' of '+num_user_points+'points) -kmh:'+kmh+' dist:'+dist+"  USER:"+unique_uid[i]);
        if(dist>min_dist_filter && dist<max_dist_filter &&
          kmh>min_speed_filter && kmh<max_speed_filter){
          
          // add first point of segment to our coord out
          if(points_used.indexOf(end_segment_index)==-1){
            filtered_data[unique_uid[i]].push(organized_data[unique_uid[i]][end_segment_index]);
            points_used.push(end_segment_index);
          }
           user_2_speeds[unique_uid[i]].push( kmh );
           user_2_dist[unique_uid[i]].push( dist );
           keep_searching=false;
        }else{
          //console.log("row removed - dist"+dist+" speed"+kmh);
        }
      }
      j=end_segment_index;
    }
    //
    console.log(unique_uid[i]+" had "+organized_data[unique_uid[i]].length+
                      " rows; now has "+filtered_data[unique_uid[i]].length);
    var coords = filtered_data[unique_uid[i]].map(function(row){ return row.coord;});
    // add each line to map
    if (coords.length>1){
      var geoJson_csv = turf.lineString(coords.map(function(gJson){
        return gJson.geometry.coordinates;
      }));
        filtered_tracks.addData(geoJson_csv);
     }
  }
  // redraw map- ONLY using our new dataset
}

function create_basic_track_filters(data_in, updateCharts){
  var users = Object.keys(data_in);
  var max_speed = 0;
  var max_dist = 0;
  for(var userCntr=0; userCntr<users.length; userCntr+=1) {

    var segment_attributes = {};
    var speed_2_segments = {};
    var distance_2_segments = {};

    var coords = data_in[users[userCntr]];

        /////////// coords [ {"timestamp":  ,  "coord":turf.point([long, lat])}]
        for(var i=0; i<coords.length; i+=1) {
            var point_i = coords[i].coord;
            var time_i =  coords[i].timestamp;
            for(var j=0; j<coords.length; j+=1) {    
                if (i != j){
                  var point_j = coords[j].coord;
                  var time_j =  coords[j].timestamp;

                    // calculate distance
                    var dist = turf.distance(point_i,point_j);
                    if(dist>max_dist){
                      max_dist = dist;
                    }
                    var bearing = turf.bearing(point_i,point_j)
                    var time_delta = moment(time_j) - moment(time_i);
                    //calculate speed
                    var speed = dist * ( time_delta / 3600000);
                    if(speed>max_speed){
                      max_speed = speed;
                    }
                    // save off info
                    segment_attributes[i,j] = {'dist':dist, 'time_delta':time_delta, 'speed' : speed };

                    // data for filtering
                    if(!speed_2_segments.hasOwnProperty()){
                        speed_2_segments[speed] = [];
                    }if(!distance_2_segments.hasOwnProperty()){
                        distance_2_segments[dist] = [];
                    }
                    speed_2_segments[speed].push([i,j]);
                    distance_2_segments[dist].push([i,j]);
                }
            };
        };
        user_coords_summary[users[userCntr]] = { 'attr':segment_attributes,
                'speeds': speed_2_segments, 'dist':distance_2_segments };
      }

      // update range sliderts
      console.log("speed",max_speed,"dist", max_dist);
      $( "#speed-range" ).slider({
        range: true,
        min: 0,
        max: max_speed,
        values: [ 0, max_speed ],
        slide: function( event, ui ) {
          $( "#speed-amount" ).val(  ui.values[ 0 ] + " - " + ui.values[ 1 ] );
        }
      });
      $( "#speed-amount" ).val( $( "#speed-range" ).slider( "values", 0 ) +
        " - " + $( "#speed-range" ).slider( "values", 1 ) );
      $( "#speed-amount").change(function(){
        var new_vals = $( "#speed-amount" ).val().split(" - ");
        $( "#speed-range" ).slider( "values", 0, new_vals[0] );
        $( "#speed-range" ).slider( "values", 1, new_vals[1] );
      }); 

    $( "#dist-range" ).slider({
        range: true,
        min: 0,
        max: max_dist,
        values: [ 0, max_dist ],
        slide: function( event, ui ) {
          $( "#dist-amount" ).val(  ui.values[ 0 ] + " - " + ui.values[ 1 ] );
        }
      });
      $( "#dist-amount" ).val(  $( "#dist-range" ).slider( "values", 0 ) +
        " - " + $( "#dist-range" ).slider( "values", 1 ) );
      $( "#dist-amount").change(function(){
        var new_vals = $( "#dist-amount" ).val().split(" - ");
        $( "#dist-range" ).slider( "values", 0, new_vals[0] );
        $( "#dist-range" ).slider( "values", 1, new_vals[1] );
      }); 

    }
  </script>

</html>
